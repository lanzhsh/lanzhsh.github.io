
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>兰志盛的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="LanZhiSheng">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="兰志盛的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="兰志盛的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="兰志盛的博客">

    
    <link rel="alternative" href="/atom.xml" title="兰志盛的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/logo1.png">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
    <div>
        
            <div id="imglogo">
                <a href="/"><img src="/img/logo1.png" alt="兰志盛的博客" title="兰志盛的博客"/></a>
            </div>
            
                <div id="textlogo">
                    <h1 class="site-name">
                        <a href="/" title="兰志盛的博客">
                            兰志盛的博客
                        </a>
                    </h1>
                    <h2 class="blog-motto">
                        
                    </h2>
                </div>
                <div class="navbar">
                    <a class="navbutton navmobile" href="#" title="菜单">
                    </a>
                </div>
                <nav class="animated">
                    <ul>
                        <ul>
                            
                                <li>
                                    <a href="/archives">
                                        目录
                                    </a>
                                </li>
                                
                                <li>
                                    <a href="/about">
                                        关于作者
                                    </a>
                                </li>
                                
                                    <li>
                                        
                                                        <form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
                                                            <label>Search</label>
                                                            <input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
                                                            <input type="hidden" name="q" value="site:yoursite.com">
                                                        </form>
                                                        
                                    </li>
                        </ul>
                </nav>
    </div>
    </header>
    <div id="container">
      <script>
    location.href = '/archives';
</script>
<div id="main">
    
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/15/vue项目开发遇到的bug/" title="vue项目开发遇到的经典bug" itemprop="url">vue项目开发遇到的经典bug</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2017-07-15T15:23:00.000Z" itemprop="datePublished"> 发表于 2017-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="使用v-for产生的bug"><a href="#使用v-for产生的bug" class="headerlink" title="使用v-for产生的bug"></a>使用v-for产生的bug</h3><p>1.应用场景:<br>通过vue实例的$http从后台请求数据,储存到data的返回值进而绑定到页面,数据有重复就会用到v-for指令</p>
<p>2.产生的问题:<br>当我们遍历每一个item的时候,采用是就地复用的原则,下一个item会复用上一个item,这两个item会指向同一个内存空间,当改变模型,会导致几个地方一起改</p>
<p>3.解决方法:<br>2.v1.x版本在里面加上track-by:’$index’<br>V2.x加上每一个id,<br>如果后台没有返回固定的id,可以用数组的下标代替</p>
<h3 id="webpack打包使用指令报错"><a href="#webpack打包使用指令报错" class="headerlink" title="webpack打包使用指令报错"></a>webpack打包使用指令报错</h3><p>1.解决方法:<br>检查指令<br>干掉本地项目的node_modules<br>去目录C:\Users\Administrator\AppData\Roaming,删掉npm,cnpm-cache重启电脑,重新安装node</p>
<h3 id="vue实例的this问题"><a href="#vue实例的this问题" class="headerlink" title="vue实例的this问题"></a>vue实例的this问题</h3><p>1.应用场景:<br>methods被混入到vue实例中,可以通过vue实例访问呢这些方法,this就是指向vue实例</p>
<p>2.产生的问题:<br>在watch里面使用箭头函数无法用this获取方法,因为箭头函数绑定了父级作用域的上下文</p>
<p>3.解决方法:<br>直接使用普通函数<br>特例:vue-Router里面封装了处理this的方法,可以直接使用.</p>
<h3 id="route检测路由问题"><a href="#route检测路由问题" class="headerlink" title="$route检测路由问题"></a>$route检测路由问题</h3><p>1.应用场景:SPA页面开发,头部和底部需要根据不同的路由显示不同,如headTab的返回和footTab</p>
<p>2.产生的问题:怎么检测路由的变化,页面单个刷新路由没变化但还是要实现效果</p>
<p>3.解决方法:<br>A.在methods定义一个函数判断路由是否变化,在watch应用$route会有newValue和oldValue值,在函数调用方法<br>B.单页刷新不能触发$route,但是可以利用组件生命周期钩子的created方法</p>
<h3 id="父子组件的通讯问题"><a href="#父子组件的通讯问题" class="headerlink" title="父子组件的通讯问题"></a>父子组件的通讯问题</h3><p>1.应用场景:<br>vue开发,有多个页面部分功能相同时</p>
<p>2.解决方法:<br>A.创建子组件</p>
<p>B.子组件设置props属性<br>  props:[‘commentId’]</p>
<p>C.集成:<br>  1.在父组件导入子组件<br>  2.注册子组件<br>  components:{<br>  subcomment:subcomment<br>  }<br>  3.在父组件的template标签中直接使用submment标签,自定义一个commentId的属性传值</p>
<p>D.子元素通过this.commentId获取值</p>
<h3 id="组件生命周期钩子解决的问题"><a href="#组件生命周期钩子解决的问题" class="headerlink" title="组件生命周期钩子解决的问题"></a>组件生命周期钩子解决的问题</h3><p>1.created(组件创建后)发送网络请求;</p>
<p>2.记录下一次浏览的记录,在destroy可以设置本次的scrollTop值,在下次mounted(挂载完成)可以拿出下一次值</p>
<p>3.app埋点:就是记录用户在web模块停留的时间,created记录t1,退出beforeDestroy记录一个时间,destroy记录时间差发送到服务器</p>
<p>4.$.ajaxSetup()为以后设置ajax请求设置默认值,beforeSend发送之前,complete完成</p>
<h3 id="loader无法预处理非js文件问题"><a href="#loader无法预处理非js文件问题" class="headerlink" title="loader无法预处理非js文件问题"></a>loader无法预处理非js文件问题</h3><p>1.解决方法:</p>
<p>css文件<br>安装css-loader和style-loader,在webpack.develop.config配置test: /.css$/,loader: ‘style-loader!css-loader’</p>
<p>ttf和png文件<br>安装url-loader和file-loader</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/22/mySQL的CRUD/" title="mySQL的CRUD" itemprop="url">mySQL的CRUD</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2017-05-22T14:02:04.000Z" itemprop="datePublished"> 发表于 2017-05-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="数据库的作用"><a href="#数据库的作用" class="headerlink" title="数据库的作用"></a>数据库的作用</h3><p>sql数据库：提供了安全机制、便于通过<strong>Sql语句</strong>对数据直接进行操作</p>
<h3 id="数据化可视工具navicat的使用"><a href="#数据化可视工具navicat的使用" class="headerlink" title="数据化可视工具navicat的使用"></a>数据化可视工具navicat的使用</h3><h5 id="1-安装phpstudy或者appach-php-mysql"><a href="#1-安装phpstudy或者appach-php-mysql" class="headerlink" title="1.安装phpstudy或者appach+php+mysql"></a>1.安装phpstudy或者appach+php+mysql</h5><h5 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h5><h6 id="A-INSERT-INTO-插入"><a href="#A-INSERT-INTO-插入" class="headerlink" title="A.INSERT INTO(插入)"></a>A.INSERT INTO(插入)</h6><p>插入行:INSERT INTO 表名称 VALUES (值1, 值2,….)</p>
<p>插入列:INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….)</p>
<p>指定列中插入数据:INSERT INTO table_name (列1, 列2) VALUES (值1, 值2)</p>
<h6 id="B-update-更新"><a href="#B-update-更新" class="headerlink" title="B.update(更新)"></a>B.update(更新)</h6><p>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</p>
<h5 id="C-delete"><a href="#C-delete" class="headerlink" title="C.delete"></a>C.delete</h5><p>DELETE FROM 表名称 WHERE 列名称 = 值</p>
<p>删除所有行:DELETE FROM table_name</p>
<h5 id="D-select"><a href="#D-select" class="headerlink" title="D.select"></a>D.select</h5><p>SELECT 列名称 FROM 表名称</p>
<p>A.distinct选出表中不同的值:SELECT DISTINCT Company FROM Orders</p>
<p>B.where规定选择的标准:&gt;,=,&lt;等,删选的字符串必须加引号,</p>
<p>SELECT * FROM Persons WHERE FirstName=’Bush’</p>
<p>C.and和or</p>
<p>D.order by,通过什么排序<br>默认升序排列,降序后加DESC关键字</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/05/NodeJS之ExpressJS框架/" title="NodeJS之ExpressJS框架" itemprop="url">NodeJS之ExpressJS框架</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2017-05-05T13:22:51.000Z" itemprop="datePublished"> 发表于 2017-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>nodeJS的一个框架,扩展了一些功能</p>
<h3 id="创建一个WEB服务器"><a href="#创建一个WEB服务器" class="headerlink" title="创建一个WEB服务器"></a>创建一个WEB服务器</h3><pre><code>var express = require(&apos;express&apos;);

// 创建一个 app 出来
var app = express();

// 捕获 get 类型的 / 请求
app.get(&apos;/&apos;, function (req, res) {
// 支持原生的 end 方法
res.end(&apos;OK&apos;);
});
// 捕获 get 类型的 /a 请求
app.get(&apos;/a&apos;, function (req, res) {
// 通过 express 封装的 send 方法，返回内容，会
自动添加响应头，更加方便便捷
res.send(&apos;&lt;h1&gt;你好啊&lt;/h1&gt;&apos;);
 });

// 启动 app 监听程序
app.listen(3000, function () {
console.log(&apos;App running at http://
127.0.0.1:3000&apos;);
});
</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h5 id="A-作用"><a href="#A-作用" class="headerlink" title="A.作用"></a>A.作用</h5><p>是一个函数，它可以访问请求对象(req), 响应对象(res)</p>
<p>经过中间件的处理之后，express就向 req 和 res ,对象身上，挂在了一些好用的方法和属性 req.query res.send() res.json()</p>
<h5 id="B-分类"><a href="#B-分类" class="headerlink" title="B.分类"></a>B.分类</h5><p>1.应用级别:绑定到app对象上的,如app.use()<br>2.路由:router.use()<br>3.错误处理:app.use((err,req,res,next=&gt;{})),有四个参数<br>4.内置中间件:express.static(root,[options])<br>5.第三方:通过npm下载的,如cookie-parser,body-parse(可以处理post提交过来的数据)</p>
<h3 id="body-parse使用步骤"><a href="#body-parse使用步骤" class="headerlink" title="body-parse使用步骤"></a>body-parse使用步骤</h3><p>主要处理post提交过来的数据</p>
<p>方法:1. 使用 npm 安装 2. 导入 这个第三方中间件 模块 3. 使用 app.use()注册刚才导入的中间件，到 app身上</p>
<h3 id="使用路由方法"><a href="#使用路由方法" class="headerlink" title="使用路由方法"></a>使用路由方法</h3><p>1.创建自己的router.js文件</p>
<p>2.导入express模块<br>Var express=require(‘express’);<br>Var app=express();</p>
<p>3.另外一个文件创建路由<br>Var router=express.Router()</p>
<p>4.注册路由模块,使用app.use<br>App.use(router);</p>
<h3 id="ejs模板"><a href="#ejs模板" class="headerlink" title="ejs模板"></a>ejs模板</h3><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>1.是express中的默认模板引擎,使用</p>
<p>2.art-template是nodeJS创建的web服务器中可以直接使用</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>1.安装<br>2.注册app.set(‘view engine’, ‘ejs’);<br>3.修改默认的模板文件存放路径app.set(‘views’, __dirname + ‘/views’);<br>4.使用ejs将模板渲染出来，同时将渲染的结果发送给客户端</p>
<h5 id="art-tempalte模板"><a href="#art-tempalte模板" class="headerlink" title="art-tempalte模板"></a>art-tempalte模板</h5><ol>
<li><p>先安装相关的包：<br>npm install –save art-template<br>npm install –save express-art-template</p>
</li>
<li><p>使用 app.engine自定义一个模板引擎<br>app.engine(‘art’, require(‘express-art-template’));</p>
</li>
<li><p>使用app.set把自定义的模板引擎，设置为express 默认的模板引擎：<br>app.set(‘view engine’, ‘art’);</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/05/nodeJS的异步I-O和事件驱动/" title="nodeJS的异步I/O和事件驱动" itemprop="url">nodeJS的异步I/O和事件驱动</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2017-04-05T14:45:14.000Z" itemprop="datePublished"> 发表于 2017-04-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>commonJS模块内容?<br>nodeJS是基于如何实现异步的I/O模型?<br>事件驱动和线程驱动是怎么实现的?</p>
<h3 id="nodeJS单线程"><a href="#nodeJS单线程" class="headerlink" title="nodeJS单线程"></a>nodeJS单线程</h3><p>一直说的单线程，都是javascript端的，Node底层还是使用c来实现，因此底层仍然是多线程的。只不过，Node基于不同的操作系统linux或者windows之上实现了一个封装层，用户执行的操作命令会转交给这个封装层，由它再去判断操作系统，进而调用相应平台的c代码。<br>但是在执行I/O操作时,会去封装层开一个独立的线程来执行I/O操作</p>
<p><img src="/img/node单线程.png" alt=""></p>
<h3 id="commonJs产生"><a href="#commonJs产生" class="headerlink" title="commonJs产生"></a>commonJs产生</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>1.js方面<br>无模块系统,ES6出来有了<br>没有包管理,导致js应用没有自加载和安装依赖能力<br>无标准接口</p>
<p>2.选择同步<br>因为服务器端很多文件都是存贮在本地</p>
<h5 id="commonJS定义的模块"><a href="#commonJS定义的模块" class="headerlink" title="commonJS定义的模块"></a>commonJS定义的模块</h5><p>1.模块<br>模块导出:node中一个文件就是一个模块,导出方法,exports变量和model.exports<br>模块引用:require()<br>模块标识:引入的模块后缀为 .js / .json / .node 可以省略</p>
<p>2.模块原理<br>模块缓存机制:可以缓存对象,浏览器缓存的是文件</p>
<p>3.模块种类<br>核心模块:node官网提供的,js提供的,c/c+核心模块,核心模块是在安装node直接嵌套在文件里<br>文件模块:开发者编写的</p>
<p>4.模块加载顺序<br>缓存,核心模块,三方模块</p>
<p>5.模块编译<br>js文件：通过fs核心模块同步读取后编译执行<br>node文件：C/C++扩展文件，通过dlopen()加载最后编译生成的文件<br>json文件：通过fs核心模块同步读取后利用JSON.parse()解析<br>其他：均当做.js文件处理</p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><h5 id="线程驱动"><a href="#线程驱动" class="headerlink" title="线程驱动"></a>线程驱动</h5><p>收到一个请求,如果线程池有空闲会打开一个新的线程,没有空闲新来的请求会在队列排队</p>
<h5 id="事件驱动-1"><a href="#事件驱动-1" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>收到一个新请求,请求被压入队列中,然后通过循环来检测队列事件状态变化,变化执行大骂</p>
<h5 id="事件驱动几个过程"><a href="#事件驱动几个过程" class="headerlink" title="事件驱动几个过程"></a>事件驱动几个过程</h5><p>执行js代码,事件循环,事件被触发则执行回调函数,异步I/O执行</p>
<h5 id="事件驱动模型注意的几个点"><a href="#事件驱动模型注意的几个点" class="headerlink" title="事件驱动模型注意的几个点"></a>事件驱动模型注意的几个点</h5><p>nodeJS在js端是单线程,所以顺序执行js代码时,事件循环是在执行完js后<br>事件循环是从消息队列中取出消息,执行回调函数<br>执行回调函数事件循环是暂停的</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/02/nodeJS基本使用/" title="nodeJS基本使用" itemprop="url">nodeJS基本使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2017-04-02T15:09:59.000Z" itemprop="datePublished"> 发表于 2017-04-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>就是服务器端的javascript,是基于Chrome V8引擎</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>使用了一个事件驱动,非阻塞式I/O的模型,事件驱动:触发事件才执行,I/O:提高处理效率<br>组成部分:ECMAScript+核心API+第三方API<br>node下载完成后自带npm包管理工具</p>
<h3 id="node执行方式"><a href="#node执行方式" class="headerlink" title="node执行方式"></a>node执行方式</h3><p>直接在命令行执行(用的很少)<br>写入到JS代码中,通过node文件路径执行</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>配置后可以通过命令快速打开程序</p>
<h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><h5 id="文件处理fs"><a href="#文件处理fs" class="headerlink" title="文件处理fs"></a>文件处理fs</h5><p>readfile()读取;有三个参数,第一个是文件路径;第二个编码格式,可省,默认是二进制,第三个回调</p>
<p>template()读取并渲染到页面,二个参数,第一个是路径,第一个是对象;</p>
<p>writeFile()写文件,四个参数,第一个是写入路径,二是写入的内容,三是编码格式,四是回调函数</p>
<p>stat()根据文件路径读取文件信息</p>
<pre><code>var fs = require(&apos;fs&apos;);
var moment = require(&apos;moment&apos;);
fs.stat(__dirname + &apos;/01.readFileSync.js&apos;, 
(err, stats) =&gt; {
  if (err) throw err;
  console.log(moment(stats.mtime).format
(&apos;YYYY-MM-DD HH:mm:ss&apos;));
});
</code></pre><h5 id="使用核心模块操作文件的路径问题"><a href="#使用核心模块操作文件的路径问题" class="headerlink" title="使用核心模块操作文件的路径问题"></a>使用核心模块操作文件的路径问题</h5><p>使用fs模块操作文件的是通过./去找文件时,不是根据当前的代码所在目录去查找,是根据当前运行node命令时所在目录查找,为了解决Node中的fs模块路径问题,Node提供了一个_dirname</p>
<h5 id="node的WEB服务器创建步骤"><a href="#node的WEB服务器创建步骤" class="headerlink" title="node的WEB服务器创建步骤"></a>node的WEB服务器创建步骤</h5><pre><code>//1.引入http模块
var http = require(&apos;http&apos;);
// 2. 创建一个Web服务器
var server = http.createServer();
//3.监听服务器
server.listen(3000, () =&gt; {
console.log(&apos;http://127.0.0.1:3000&apos;);
});
//4.绑定事件
server.on(&apos;request&apos;, (req, res) =&gt; {
res.writeHeader(200, {
&apos;Content-Type&apos;: &apos;text/plain; charset=utf-8&apos;;
//返回值
res.end(&apos;走吧，装完了！！！&apos;);
  });
</code></pre><h5 id="node的模块化"><a href="#node的模块化" class="headerlink" title="node的模块化"></a>node的模块化</h5><p>A.module:模块,node最常见的是一个个JS文件<br>B.Require:加载其他模块用的,在JS中引用其他的模块是require<br>C.Exports:模块向外暴露成员,供其他JS模块使用<br>D.Require和exports是属于module对象里面的属性</p>
<h5 id="模块的执行顺序"><a href="#模块的执行顺序" class="headerlink" title="模块的执行顺序"></a>模块的执行顺序</h5><p>先优先从缓存中执行,可以加快程序的运行速度<br>加载核心模块<br>用户的模块(开发者自己写的)<br>第三方查找规则</p>
<h5 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h5><p>path.join()配置路径</p>
<h5 id="nodeJS实际开发项目模块分类"><a href="#nodeJS实际开发项目模块分类" class="headerlink" title="nodeJS实际开发项目模块分类"></a>nodeJS实际开发项目模块分类</h5><p><img src="/img/nodeC.png" alt=""><img src="/img/nodeMV.png" alt=""></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/01/13/构建神器webpack与gulp/" title="构建神器webpack与gulp" itemprop="url">构建神器webpack与gulp</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2017-01-13T14:09:49.000Z" itemprop="datePublished"> 发表于 2017-01-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><p>1.x和2.x,1.x使用loader预处理一些文件时导入时可以省略,2.x里面不可以省略</p>
<h5 id="打包单文件和多文件"><a href="#打包单文件和多文件" class="headerlink" title="打包单文件和多文件"></a>打包单文件和多文件</h5><p>单文件:直接打包<br>多文件:找到入口文件,然后找到依赖文件<br>命令:webpack entry.js bundle.js</p>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>–progress:查看打包进度<br>-p 压缩bundle.js,需要借助babel<br>–watch:监听源代码的更改<br>–config:,如果webpack的配置文件不叫webpack.config.js,打包是要使用–config指定</p>
<h5 id="打包非js文件"><a href="#打包非js文件" class="headerlink" title="打包非js文件"></a>打包非js文件</h5><p>需要用到loader模块<br>常用的loader模块:<br>style-loader将解析好的css插入header的<style>中;<br>babel-loader,url-loader(路径),file-loader(文件预处理)</p>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><p>–open 打开默认浏览器<br>–port 6088<br>–hot 实现热重载,更新数据页面不会刷新</p>
<h5 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h5><p>webpack-dev-server –progress –config webpack.develop.config.js –port6008 –open –hot</p>
<p>###两者的异同点</p>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><p>都是运行在终端,都可以用来打包指令一样</p>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><p>webpack:用在成产阶段<br>web-dev-server:开发阶段</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>1.开发阶段:可以以一个模板文件(template.html)为参照,在内存中指定一个index.html文件,     不会在实际文件中看到<br>2.也就相当与每次刷新不用重新打包;</p>
<h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>利用传输流,Transform Streams是NodeJS Stream的一种,是可读可写的</p>
<h5 id="几个方法"><a href="#几个方法" class="headerlink" title="几个方法"></a>几个方法</h5><p>task创建任务,<br>src读,<br>dest写,<br>run运行,<br>watch监控</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>所有的代码写到gulpfile.js文件里面</p>
<pre><code>gulp.task(&apos;copy&apos;, function() {
gulp.src(&apos;src/js/sm_view.js&apos;)
    .pipe(gulp.dest(&apos;dist/js/&apos;));
});
</code></pre></style></p>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/23/vue项目搭建/" title="vue项目搭建" itemprop="url">vue项目搭建</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2016-12-23T14:45:38.000Z" itemprop="datePublished"> 发表于 2016-12-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="手动搭建脚手架"><a href="#手动搭建脚手架" class="headerlink" title="手动搭建脚手架"></a>手动搭建脚手架</h3><h5 id="1-配合使用的插件有"><a href="#1-配合使用的插件有" class="headerlink" title="1.配合使用的插件有"></a>1.配合使用的插件有</h5><p>webpack-dev-server<br>html-webpack-plugin<br>两个插件的配合使用最后将入口文件main.js打包成bundle.js文件</p>
<h5 id="1-创建文件及文件夹"><a href="#1-创建文件及文件夹" class="headerlink" title="1.创建文件及文件夹"></a>1.创建文件及文件夹</h5><p>src:项目的源代码,src里面有App.vue(根组件),<br>package.json:项目配置文件<br>webpack.develop.config:开发阶段的webpack配置文件<br>template.html:html-webpack-plugin会将该文件参照，在内存中生成一个指定名称的(index.html)的文件,也就相当于每次改变不用重新打包</p>
<h5 id="2-开发阶段配置文件书写"><a href="#2-开发阶段配置文件书写" class="headerlink" title="2.开发阶段配置文件书写"></a>2.开发阶段配置文件书写</h5><pre><code>var path = require(&apos;path&apos;)
//每次刷新不用重新打包
var HtmlWebpackPlugin = require
(&apos;html-webpack-plugin&apos;)
module.exports = {
//打包的入口文件
entry: &apos;./src/main.js&apos;, 
output: {
    //bundle.js放的目录
    path: __dirname, 
    //打包出来的文件名称
    filename: &apos;bundle.js&apos; 
},
module: {
//loader预处理文件
loaders: [{
    test: /\.vue$/,
    loader: &apos;vue-loader&apos;
},
{
    test: /\.css$/,
    loader: &apos;style-loader!css-loader&apos;
},
{
    test: /\.(ttf|png)$/,
    loader: &apos;url-loader&apos;
}
]
},
plugins: [
    //初始化实例
    new HtmlWebpackPlugin({
        filename: &apos;index.html&apos;, 
    //内存中生成的文件名称
        template: &apos;./template.html&apos;
     //模版文件
    })
]
}
</code></pre><h3 id="可以用vue-cli搭建"><a href="#可以用vue-cli搭建" class="headerlink" title="可以用vue-cli搭建"></a>可以用vue-cli搭建</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code>npm i -g vue-cli
</code></pre><h5 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h5><p>vue init webpack-simple vue_simple_demo</p>
<h5 id="切换到根目录安装依赖的包"><a href="#切换到根目录安装依赖的包" class="headerlink" title="切换到根目录安装依赖的包"></a>切换到根目录安装依赖的包</h5><p>npm i</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>脚手架里面有个.babelrc文件,webpack集成了babelrc将ES6语法转为ES5</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/15/vue组件书写代码段/" title="vue组件书写代码段" itemprop="url">vue组件书写代码段</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2016-12-15T15:11:43.000Z" itemprop="datePublished"> 发表于 2016-12-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="VSCode编辑器"><a href="#VSCode编辑器" class="headerlink" title="VSCode编辑器"></a>VSCode编辑器</h3><p>设置–用户–代码块–选择vue–复制以下代码</p>
<pre><code>&quot;my_vue&quot;: {
    &quot;prefix&quot;: &quot;my_vue&quot;,
    &quot;body&quot;: [
        &quot;&lt;template&gt;&quot;,
        &quot;   &lt;div class=&apos;tmpl&apos;&gt;&quot;,
        &quot;        $0&quot;,
        &quot;   &lt;/div&gt;&quot;,
        &quot;&lt;/template&gt;&quot;,
        &quot;    &quot;,
        &quot;&lt;style scoped&gt;&quot;,
        &quot;    &quot;,
        &quot;&lt;/style&gt;&quot;,
        &quot;    &quot;,
        &quot;&lt;script&gt;&quot;,
        &quot;    import common from &apos;../
        ../common/common.js&apos;&quot;,
        &quot;    &quot;,
        &quot;    export default {&quot;,
        &quot;        data() {&quot;,
        &quot;            return {&quot;,
        &quot;            }&quot;,
        &quot;        },&quot;,
        &quot;        created() {&quot;,
        &quot;            &quot;,
        &quot;        },&quot;,
        &quot;        methods: {&quot;,
        &quot;            &quot;,
        &quot;        }&quot;,
        &quot;    }&quot;,
        &quot;&lt;/script&gt;&quot;
    ],
    &quot;description&quot;: &quot;快速创建vue模板&quot;
}
</code></pre><h3 id="几个主要属性"><a href="#几个主要属性" class="headerlink" title="几个主要属性"></a>几个主要属性</h3><p>data:Vue实例的数据对象,组件的定义只接受函数<br>created:检测组件刚创建的时候执行的代码<br>methods:可以直接混入到vue实例中,可以通过this(也就是vue实例)访问这些方法<br>watch:检测一些变化,如路由值</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/13/vue路由及对应组件的使用/" title="Vue-Router和Vue-Resource" itemprop="url">Vue-Router和Vue-Resource</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2016-12-13T15:02:02.000Z" itemprop="datePublished"> 发表于 2016-12-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="组件的定义方式"><a href="#组件的定义方式" class="headerlink" title="组件的定义方式"></a>组件的定义方式</h3><p>定义,注册,使用<br>自定义template标签定义组件<br>自定义script定义组件</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h5><p>npm i vue-router -S</p>
<h5 id="2-导入vue-router"><a href="#2-导入vue-router" class="headerlink" title="2.导入vue-router"></a>2.导入vue-router</h5><p>import vueRouter from vue-router</p>
<h5 id="3-导入需要设置路由规则的组件"><a href="#3-导入需要设置路由规则的组件" class="headerlink" title="3.导入需要设置路由规则的组件"></a>3.导入需要设置路由规则的组件</h5><p>import home from ‘./components/home/home.vue’</p>
<h5 id="4-创建路由实例-设置规则"><a href="#4-创建路由实例-设置规则" class="headerlink" title="4.创建路由实例,设置规则"></a>4.创建路由实例,设置规则</h5><p>const router = new VueRouter({<br>routes: [<br>{ path: ‘/category’, component: category },<br>]<br>})</p>
<h5 id="5-创建和挂载实例-通过router配置参数注入路由"><a href="#5-创建和挂载实例-通过router配置参数注入路由" class="headerlink" title="5.创建和挂载实例,通过router配置参数注入路由"></a>5.创建和挂载实例,通过router配置参数注入路由</h5><p>new Vue({<br>el: “#app”,<br>router,<br>render: function(createElement) { //项目一启动之后，呈现给用户的第一个组件<br>return createElement(App)<br>}<br>})</p>
<h3 id="vue-resource"><a href="#vue-resource" class="headerlink" title="vue-resource"></a>vue-resource</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>对ajax的封装,后台请求数据</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>安装<br>npm i vue-source -S</p>
<p>导入<br>在main.js中import vueResource from ‘vue-resource’</p>
<p>集成<br>Vue,use(vueResource)</p>
<p>导出<br>在对应组件中使用,用export default导出Vue对象,是给数据提供数据和用户交互</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code>export default{
//data指的是数据对象
data(){
  return{
    lunboArray:[]
  }
},
created(){
  this.getLunboData()
},
methods:{
  //获取需要的数据
  getLunboData(){
    const url=&apos;http://182.254.
    146.100:8899/api/getlunbo&apos;;
    this.$http.get(url).then
    (response=&gt;{
      console.log(response);
      this.lunboArray=response.
        body.message
    })
  }
}
}
</code></pre><h3 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h3><p>$route是设置路径相关,比如监控路由,获取参数</p>
<p>$router执行者,执行一个动作<br>写js代码实现路由的前进后退和回退,也叫编程式导航</p>
<pre><code>goBack(){
    this.$router.go(-1)
  }
</code></pre><h3 id="导航分类"><a href="#导航分类" class="headerlink" title="导航分类"></a>导航分类</h3><p>编程式导航:写js代码实现路由的前进后退和回退<br>声明式导航:事先声明在template标签里面</p>
<pre><code>&lt;router-link to=&quot;/news/newslist&quot;&gt;
&lt;/router-link&gt;
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
         
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/15/ES6常用规范/" title="ES6常用规范" itemprop="url">ES6常用规范</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="LanZhiSheng" target="_blank" itemprop="author">LanZhiSheng</a>
		
  <p class="article-time">
    <time datetime="2016-11-15T15:30:28.000Z" itemprop="datePublished"> 发表于 2016-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>由于ES6.1是2016年6月发布的,所以在此之前的浏览器都不支持,但是可以利用babel插件将ES6转化为ES5语法</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>npm i babel-core<br>导入核心的browser.js</p>
<h3 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h3><p>let:定义变量,没有预解析,有块级作用域,花括号可以分割作用域<br>const:定义常量,没有预解析,有块级作用域</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>数组和对象可以直接对应赋值</p>
<p>let [a,b,c]=[1,2,3]<br>let [x, y, z] = new Set([‘a’, ‘b’, ‘c’]);</p>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><p>0b(B)二进制<br>0o(O)八进制</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>var f = () =&gt; 5;<br>// 等同于<br>var f = function () { return 5 };</p>
<p>箭头函数返回的是一个对象,要用花括号<br>var sum = (num1, num2) =&gt; num1 + num2;<br>// 等同于<br>var sum = function(num1, num2) {<br>  return num1 + num2;<br>};</p>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><p>键值相同,值可以省略</p>
<p>module.exports = { getItem, setItem, clear };<br>// 等同于<br>module.exports = {<br>  getItem: getItem,<br>  setItem: setItem,<br>  clear: clear<br>};</p>
<h3 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h3><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>1.css的模块化@import,最好不要用因为相对于link来说,@import是先加载html在加载css,link是遇到先加载完成;</p>
<p>2.js后端有commonJS,前端seaJS和requireJS</p>
<h5 id="import输入"><a href="#import输入" class="headerlink" title="import输入"></a>import输入</h5><p>js引擎遇到import只会生成一个只读应用,脚本执行再去找值,原始值变加载值也变</p>
<p>import { stat, exists, readFile } from ‘fs’;</p>
<h5 id="export输出"><a href="#export输出" class="headerlink" title="export输出"></a>export输出</h5><p>是编译时输出接口,commonJS是运行时加载</p>
<p>export function area(radius) {<br>  return Math.PI <em> radius </em> radius;<br>}</p>
<h5 id="import和export用法结合"><a href="#import和export用法结合" class="headerlink" title="import和export用法结合"></a>import和export用法结合</h5><p>需要明确知道要加载和输入变量名和函数名</p>
<h5 id="export-default默认输出"><a href="#export-default默认输出" class="headerlink" title="export default默认输出"></a>export default默认输出</h5><p>配合import解决模块文件输入输出</p>
<pre><code>// export-default.js
export default function () {
  console.log(&apos;foo&apos;);
}

// import-default.js
import customName from &apos;./export-default&apos;;
customName(); // &apos;foo&apos;
</code></pre><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>1.ES6的模块采用严格模式</p>
<p>变量必须声明再使用<br>函数参数不能有同名属性<br>不能用with<br>this不指向全局<br>eval执行字符串代码时,作用域独立</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>





            
                
                    <nav id="page-nav" class="clearfix">
                        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
                    </nav>
                    
</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://developer.mozilla.org/zh-CN/" target="_blank" title="一个面向程序员交流分享的新一代社区">MDN</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
    <a href="/archives" target="_blank" title="rss">回到目录</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" style="width:100%;background-color:#00b38a">
    
        <div class="line">
            <span></span>
            <div class="author"></div>
        </div>
        
            
                <section class="info">
                    <p>
                        WEB前端工程师 <br/>
                            两年工作经验

                    </p>
                </section>
                
                    <!-- <div class="social-font" class="clearfix">
                        
                                
                                        
                                                
                                                        
                                                                
                                                                        
                                                                                
                                                                                        
                                                                                                
                    </div> -->
                    
                        
</div></footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
